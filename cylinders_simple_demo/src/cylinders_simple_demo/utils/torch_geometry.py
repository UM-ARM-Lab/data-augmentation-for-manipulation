from math import pi

import numpy as np
import torch
from pytorch3d.transforms import euler_angles_to_matrix


def occupied_voxels_to_points_batched(vg, res, origin_point):
    all_indices = torch.where(vg > 0.5)
    batch_indices = all_indices[0]
    indices = torch.stack(all_indices[1:], -1)
    res_gathered = torch.take_along_dim(res, batch_indices, 0)
    origin_point_gathered = torch.take_along_dim(origin_point, batch_indices.unsqueeze(-1), 0)
    occupied_points = batch_idx_to_point_3d_res_origin_point(indices, res_gathered, origin_point_gathered)
    return batch_indices, occupied_points


def pairwise_squared_distances_self(a):
    """ same as above except, specialized to one input, with the diagonal is set to inf """
    a_s = a.square().sum(dim=-1, keepdim=True)  # [b, ..., n, 1]
    d = a_s - 2 * (a @ a.transpose(-1, -2)) + a_s.transpose(-2, -1)  # [b, ..., n, n]
    n = a.shape[-2]
    batch_shape = list(a.shape[:-2])
    mask = torch.eye(n).repeat(*batch_shape, 1, 1).bool()
    d[mask] = torch.inf
    return d


def homogeneous(points):
    return torch.cat([points, torch.ones_like(points[..., 0:1])], axis=-1)


def transform_points_3d(transform_matrix, points):
    """

    Args:
        transform_matrix: [b1, b2, ..., 4, 4]
        points: [b1, b2, ..., 3]

    Returns:

    """
    points_homo = homogeneous(points)
    points_homo = points_homo.unsqueeze(-1)
    transformed_points = torch.matmul(transform_matrix, points_homo)
    return transformed_points.squeeze(-1)[..., :3]


def round_to_res(x, res):
    # helps with stupid numerics issues
    return torch.round(x / res).long()


def swap_xy(x):
    """

    Args:
        x: has shape [b1, b2, ..., bn, 3]

    Returns: the x/y will be swapped

    """
    first = x[..., 0]
    second = x[..., 1]
    z = x[..., 2]
    swapped = torch.stack([second, first, z], dim=-1)
    return swapped


def batch_point_to_idx(points, res, origin_point):
    """

    Args:
        points: [b1,...,bn,3] points in a frame, call it world
        res: [b1,...,b2] meters
        origin_point: [b1,...,b2,3] the position [x,y,z] of the center of the voxel (0,0,0) in the same frame as points

    Returns:

    """
    return swap_xy(round_to_res((points - origin_point), res.unsqueeze(-1)))


def batch_idx_to_point_3d_res_origin_point(indices, res, origin_point):
    indices_xyz = swap_xy(indices)
    return indices_xyz.float() * res.unsqueeze(-1) + origin_point


# GENERATED BY SYMPY
def transformation_jacobian(params):
    """

    Args:
        params:  [b1,b2,...,6]

    Returns:

    """
    x, y, z, roll, pitch, yaw = torch.unbind(params, dim=-1)
    ones = torch.ones_like(x)
    zeros = torch.zeros_like(x)
    jacobian = torch.stack([
        torch.stack([
            torch.stack([zeros, zeros, zeros, ones]),
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, zeros])
        ]),
        torch.stack([
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, ones]),
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, zeros])
        ]),
        torch.stack([
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, ones]),
            torch.stack([zeros, zeros, zeros, zeros])
        ]),
        torch.stack([
            torch.stack([zeros, torch.sin(pitch) * torch.cos(roll) * torch.cos(yaw) + torch.sin(roll) * torch.sin(yaw),
                         -torch.sin(pitch) * torch.sin(roll) * torch.cos(yaw) + torch.sin(yaw) * torch.cos(roll),
                         zeros]),
            torch.stack([zeros, torch.sin(pitch) * torch.sin(yaw) * torch.cos(roll) - torch.sin(roll) * torch.cos(yaw),
                         -torch.sin(pitch) * torch.sin(roll) * torch.sin(yaw) - torch.cos(roll) * torch.cos(yaw),
                         zeros]),
            torch.stack([zeros, torch.cos(pitch) * torch.cos(roll), -torch.sin(roll) * torch.cos(pitch), zeros]),
            torch.stack([zeros, zeros, zeros, zeros])
        ]),
        torch.stack([
            torch.stack([-torch.sin(pitch) * torch.cos(yaw), torch.sin(roll) * torch.cos(pitch) * torch.cos(yaw),
                         torch.cos(pitch) * torch.cos(roll) * torch.cos(yaw), zeros]),
            torch.stack([-torch.sin(pitch) * torch.sin(yaw), torch.sin(roll) * torch.sin(yaw) * torch.cos(pitch),
                         torch.sin(yaw) * torch.cos(pitch) * torch.cos(roll), zeros]),
            torch.stack(
                [-torch.cos(pitch), -torch.sin(pitch) * torch.sin(roll), -torch.sin(pitch) * torch.cos(roll), zeros]),
            torch.stack([zeros, zeros, zeros, zeros])
        ]),
        torch.stack([
            torch.stack([-torch.sin(yaw) * torch.cos(pitch),
                         -torch.sin(pitch) * torch.sin(roll) * torch.sin(yaw) - torch.cos(roll) * torch.cos(yaw),
                         -torch.sin(pitch) * torch.sin(yaw) * torch.cos(roll) + torch.sin(roll) * torch.cos(yaw),
                         zeros]),
            torch.stack([torch.cos(pitch) * torch.cos(yaw),
                         torch.sin(pitch) * torch.sin(roll) * torch.cos(yaw) - torch.sin(yaw) * torch.cos(roll),
                         torch.sin(pitch) * torch.cos(roll) * torch.cos(yaw) + torch.sin(roll) * torch.sin(yaw),
                         zeros]),
            torch.stack([zeros, zeros, zeros, zeros]),
            torch.stack([zeros, zeros, zeros, zeros])
        ])
    ])  # [6,4,4,b1,b2,...]
    batch_axes = list(np.arange(len(params.shape) - 1) + 3)
    jacobian = torch.permute(jacobian, batch_axes + [0, 1, 2])
    return jacobian


def euler_angle_diff(euler1, euler2):
    abs_diff = (euler1 - euler2).abs()
    return abs_diff.minimum(2 * pi - abs_diff)


def points_to_voxel_grid_res_origin_point_batched(batch_indices, points, res, origin_point, h, w, c, batch_size):
    """
    Args:
        batch_indices: [n], batch_indices[i] is the batch indices for point points[i]. Must be int64 type
        points: [n, 3]
        res: [n]
        origin_point: [n, 3]
        h:
        w:
        c:
        batch_size:

    Returns: 1-channel binary voxel grid of shape [b,h,w,c]
    """
    indices = batch_point_to_idx(points, res, origin_point)  # [n, 4]
    rows, cols, channels = torch.unbind(indices, dim=-1)
    indices = torch.stack([batch_indices, rows, cols, channels], dim=-1)
    voxel_grid = torch.zeros([batch_size, h, w, c])
    voxel_grid[torch.unbind(indices, -1)] = 1
    return voxel_grid


def lookup_points_in_vg(state_points, env, res, origin_point, batch_size):
    """
    Returns the values of env at state_points
    Args:
        state_points: [b, n, 3], in same frame as origin_point
        env: [b, h, w, c]
        res:
        origin_point: [b, 3] in same frame as state_points
        batch_size:

    Returns: [b, n]

    """
    n_points = state_points.shape[1]
    vg_indices = batch_point_to_idx(state_points, res[:, None], origin_point[:, None])  # [b, n, 3]
    batch_indices = torch.tile(torch.arange(batch_size)[:, None], [1, n_points])  # [b, n]
    occupancy_at_state_points = env[batch_indices, vg_indices[..., 0], vg_indices[..., 1], vg_indices[..., 2]]
    return occupancy_at_state_points


def xyzrpy_to_matrices(params):
    """

    Args:
        params:  [b1,b2,...,6] in the form [x,y,z,roll,pitch,yaw]

    Returns: [b1,b2,...,4,4] with the assumption of roll, pitch, yaw, then translation (aka the normal thing)

    """
    translation = params[..., :3][..., None]
    angles = params[..., 3:]
    r33 = euler_angles_to_matrix(angles, convention='XYZ')
    r34 = torch.cat([r33, translation], dim=-1)
    bottom_row = torch.Tensor([0, 0, 0, 1])
    bottom_row = torch.ones(params.shape[:-1] + (1, 4)) * bottom_row
    matrices = torch.cat([r34, bottom_row], dim=-2)
    return matrices
